# Procedure Abstraction

* External interface
  Allow codue reuse and development of library

* Control abstraction, including
  Well defined entries and exits

* Clean name spaces

  Clean slate for writing locally visible names

## Calling Conventions

* Call-by-value
* Call-by-reference (e.g. FORTRAN77)
  Instead of coping a parameter, an address is actually passed to the callee. Modifications to the parameters will be reflected in the original variable.
* Call-by-name (Algo60, Scala)
  In the body of the procedure, the parameter names will be replaced by the actual parameters given to the procedure. It works similar to a function-macro in C.
  One interesting consequence, if `a[i]` is passed in, and `i` is change during the execution of the procedure, then the element accessed by `a[i]` will change as well.

Hardware doesn't support the full procedure abstractions (like entries & exits, interfaces, call & return mechanism, name space, nested scope). Instead the abstraction needs to be supported by the assembly code generated by the compiler.

* The original state needs before the jump needs to be stored 
* The arguments need to be passed in
* Local variables need to be allocated
* After the procedure, the original state needs to be restored

### Procedure Activation Record

The procedure activatioon record is refered to by `AR`. The `ARP` refers to either the address of the `AR` or a special register, in which the address of the `AR` is stored.

These records are created, used and destroyed during run-time and store the necessary information for procedure calls.

![image-20231020082508811](./res/6_Procedure%20Abstraction/image-20231020082508811.png)

*(Note: the caller's AR is used to access information (like variables) of the caller and to restore the AR of the caller. For this the pointer is required, since the AR has a variable size due to the local variables)*

To allocate variable length data, the compiler creates a special place in the heap for variable-length data. Then the compiler will create a pointer variable from the local variables to the variable-length data.

**TODO: Insert Variable-length Data Placement diagram**

`Addressability` is used to access the immediately lexical scope. This can be used for a function to access variables from its immediately enclosing function. However, this doesn't wouldn't support full closures, like JS would.

**TODO: Insert Addressability example**

The `return address` contains the address of the instruction to which will be jumped after the function finished.

When `f()` calls `g()`, then ` f` allocates space for the return value somewhere, and stores the address in the `returned value` of the AR. The callee, `g` in this case, would access this address via the `caller's AR` field in its AR.

## Procedure Linkages

**TODO: Insert standard procedure linkage diagram**

The prolog is at the start of each procedure, while the epilog is at the end of a procedure. The pre-call and post-call are invoked right before jumping to a function, and right after the function returned. 

**TODO: check if ARP are not AR and reverse**

The pre-call helps preserve its own environment.

* Sets up the callee's basic ARP. However, the local variables are is left to the callee (since the caller might not even see the code of the callee). 
* Each parameter is evaluated and the value or address is stored
* The return address and **TODO**

The `prolog` does the following:

* Finish setting up the callee`s environment (like setting up the local variables)
* Preserve any callee-saved registers

The `epilog` does wind up the business of the callee and start restoring the caller's environment:

* (Store the modified variables in registers to their respective addresses)
* Store the return value
* Restore the callee-saved registers
* Free space for local data, if necessary (on the heap)
* Load the return address from the AR
* Restore the caller's ARP register to its AR
* Jump to the return address

The `post-return` sequence finishs restoring the caller's environment and places any value back where it belongs:

* Free the callee's AR 
* Restore **TODO**

**TODO: add example for call-by-refernce**

Callee-saved registers are good for long-lived values, while caller-saved registers are good for short-lived values.